<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <link rel="icon" type="image/png" href="https://cdn-icons-png.flaticon.com/512/7166/7166938.png">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title data-i18n="title">Trình Tối Ưu Cắt Ván</title>
    <style>
        :root {
            --primary-color: #184D5A;
            --secondary-color: #2980b9;
            --accent-color: #e74c3c;
            --text-color: #333;
            --bg-color: #f9f9f9;
            --card-bg: #fff;
            --border-color: #ddd;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.5;
            color: var(--text-color);
            background-color: var(--bg-color);
            padding: 0.5rem;
        }

        h1, h2, h3 {
            margin-bottom: 0.5rem;
            color: var(--primary-color);
        }

        h1 {
            text-align: center;
            margin: 0.5rem 0 1rem;
            font-size: 1.5rem;
        }

        h2 {
            font-size: 1.2rem;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 1fr;
            gap: 0.75rem;
        }

        @media (min-width: 768px) {
            .container {
                grid-template-columns: 300px 1fr;
                gap: 1rem;
            }
            
            h1 {
                font-size: 1.8rem;
            }
        }

        .card {
            background: var(--card-bg);
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            padding: 0.75rem;
            margin-bottom: 0.75rem;
        }

        .form-group {
            margin-bottom: 0.5rem;
        }

        .form-row {
            display: flex;
            gap: 0.5rem;
        }

        .form-row .form-group {
            flex: 1;
        }

        label {
            display: block;
            margin-bottom: 0.25rem;
            font-weight: 500;
            font-size: 0.9rem;
        }

        input, button, select {
            width: 100%;
            padding: 0.5rem;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-size: 0.9rem;
        }

        button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            cursor: pointer;
            font-weight: 600;
            transition: background-color: 0.3s;
            margin-top: 0.25rem;
            padding: 0.6rem;
        }

        button:hover {
            background-color: var(--secondary-color);
        }

        .piece-list {
            max-height: 200px;
            overflow-y: auto;
            margin: 0.5rem 0;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 0.25rem;
        }

        .piece-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.35rem;
            border-bottom: 1px solid var(--border-color);
            font-size: 0.9rem;
        }

        .piece-item:last-child {
            border-bottom: none;
        }

        .piece-group-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.35rem;
            cursor: pointer;
            background-color: #f5f5f5;
            border-radius: 4px;
            margin-bottom: 0.25rem;
        }

        .piece-group-header:hover {
            background-color: #eee;
        }

        .piece-group-content {
            display: none;
            padding: 0.25rem 0.5rem;
        }

        .piece-group-content.active {
            display: block;
        }

        .remove-piece {
            background: var(--accent-color);
            color: white;
            border: none;
            border-radius: 4px;
            padding: 0.2rem 0.4rem;
            cursor: pointer;
            width: auto;
            font-size: 0.8rem;
            margin-top: 0;
            margin-left: 0.5rem;
        }

        .action-buttons {
            display: flex;
            gap: 0.5rem;
        }

        .action-buttons button {
            flex: 1;
        }

        .results {
            margin-top: 0.5rem;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 0.5rem;
            margin-bottom: 0.75rem;
        }

        @media (min-width: 480px) {
            .stats {
                grid-template-columns: repeat(4, 1fr);
            }
        }

        .stat-card {
            background: var(--card-bg);
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            padding: 0.6rem;
            text-align: center;
        }

        .stat-card h3 {
            font-size: 0.8rem;
            margin-bottom: 0.25rem;
        }

        .stat-card .value {
            font-size: 1.1rem;
            font-weight: 700;
            color: var(--primary-color);
        }

        .canvas-container {
            width: 100%;
            overflow-x: auto;
            margin-top: 0.5rem;
        }

        canvas {
            border: 1px solid var(--border-color);
            background-color: white;
            margin-bottom: 1rem;
        }

        .layout-tabs {
            display: flex;
            flex-wrap: wrap;
            margin-bottom: 0.5rem;
        }

        .tab-button {
            background: #d3eafa;
            color: black;
            border: 1px solid var(--border-color);
            border-bottom: none;
            border-radius: 4px 4px 0 0;
            padding: 0.4rem 0.6rem;
            margin-right: 0.25rem;
            cursor: pointer;
            font-weight: 600;
            font-size: 0.85rem;
            transition: background-color: 0.2s;
        }

        .tab-button.active {
            background: var(--primary-color);
            color: white;
        }

        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-top: 0.5rem;
            font-size: 0.85rem;
        }

        .legend-item {
            display: flex;
            align-items: center;
        }

        .legend-color {
            width: 16px;
            height: 16px;
            margin-right: 0.25rem;
            border: 1px solid #333;
        }

        .alert {
            background-color: #f8d7da;
            color: #721c24;
            padding: 0.5rem;
            border-radius: 4px;
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
            display: none;
        }

        .button-icon {
            margin-right: 0.25rem;
        }

        .accordion-header {
            padding: 0.5rem;
            background-color: #f0f0f0;
            cursor: pointer;
            border-radius: 4px;
            margin-bottom: 0.5rem;
            font-weight: 600;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .accordion-content {
            display: none;
            padding: 0 0.5rem;
        }

        .accordion-content.active {
            display: block;
        }

        .export-buttons {
            display: flex;
            gap: 0.3rem;
            margin-top: 0.5rem;
        }

        .export-buttons button {
            padding: 0.4rem 0.6rem;
            font-size: 0.85rem;
            min-width: 80px;
        }

        .language-switcher {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 1000;
        }

        .language-button {
            background: var(--primary-color);
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.3s;
        }

        .language-button:hover {
            background: var(--secondary-color);
        }

        .language-menu {
            display: none;
            position: absolute;
            top: 45px;
            right: 0;
            background: white;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            min-width: 100px;
        }

        .language-menu.active {
            display: block;
        }

        .language-menu button {
            display: block;
            width: 100%;
            padding: 0.5rem;
            border: none;
            background: none;
            text-align: left;
            cursor: pointer;
            font-size: 0.9rem;
        }

        .language-menu button:hover {
            background: var(--bg-color);
        }

        @media print {
            .controls, .language-switcher {
                display: none;
            }

            .container {
                display: block;
            }

            .card {
                box-shadow: none;
                border: 1px solid #ccc;
            }

            .canvas-container {
                page-break-inside: avoid;
            }

            .layout-tabs, 
            .export-buttons {
                display: none;
            }

            canvas {
                display: block !important;
            }
        }
    </style>
</head>
<body>
    <div class="language-switcher">
        <button class="language-button" title="Change Language">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2">
                <circle cx="12" cy="12" r="10"/>
                <path d="M2 12h20"/>
                <path d="M12 2v20"/>
                <path d="M6 6l12 12"/>
                <path d="M6 18l12-12"/>
            </svg>
        </button>
        <div class="language-menu">
            <button style="color:#333;" data-lang="vi">Tiếng Việt</button>
            <button style="color:#333;" data-lang="en">English</button>
            <button style="color:#333;" data-lang="ko">한국어</button>
        </div>
    </div>

    <h1 data-i18n="title">Trình Tối Ưu Cắt Ván</h1>
    
    <div class="container">
        <div class="controls">
            <!-- Cấu hình -->
            <div class="card">
                <div class="accordion-header" data-target="config-content">
                    <span data-i18n="config">Cấu hình</span>
                    <span class="toggle-icon">▼</span>
                </div>
                <div class="accordion-content active" id="config-content">
                    <div class="form-row">
                        <div class="form-group">
                            <label for="sheet-width" data-i18n="sheet_width">Chiều rộng (m):</label>
                            <input type="number" id="sheet-width" step="0.01" value="1.22">
                        </div>
                        <div class="form-group">
                            <label for="sheet-height" data-i18n="sheet_height">Chiều dài (m):</label>
                            <input type="number" id="sheet-height" step="0.01" value="2.44">
                        </div>
                    </div>
                    <div class="form-row">
                        <div class="form-group">
                            <label for="cut-width" data-i18n="cut_width">Độ rộng cắt (mm):</label>
                            <input type="number" id="cut-width" value="3">
                        </div>
                        <div class="form-group">
                            <label for="algorithm" data-i18n="algorithm">Thuật toán:</label>
                            <select id="algorithm">
                                <option value="maxrects">MaxRects</option>
                                <option value="guillotine">Guillotine</option>
                            </select>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Thêm mảnh ván -->
            <div class="card">
                <div class="accordion-header" data-target="add-piece-content">
                    <span data-i18n="add_piece">Thêm mảnh ván cần cắt</span>
                    <span class="toggle-icon">▼</span>
                </div>
                <div class="accordion-content active" id="add-piece-content">
                    <div class="alert" id="error-message"></div>
                    <div class="form-row">
                        <div class="form-group">
                            <label for="piece-width" data-i18n="piece_width">Chiều rộng (m):</label>
                            <input type="number" id="piece-width" step="0.01" value="0.5">
                        </div>
                        <div class="form-group">
                            <label for="piece-height" data-i18n="piece_height">Chiều dài (m):</label>
                            <input type="number" id="piece-height" step="0.01" value="0.5">
                        </div>
                    </div>
                    <div class="form-row">
                        <div class="form-group">
                            <label for="piece-quantity" data-i18n="quantity">Số lượng:</label>
                            <input type="number" id="piece-quantity" value="1" min="1">
                        </div>
                        <div class="form-group">
                            <label for="piece-name" data-i18n="piece_name">Tên (tùy chọn):</label>
                            <input type="text" id="piece-name" placeholder="VD: Mặt bàn" data-i18n-placeholder="piece_name_placeholder">
                        </div>
                    </div>
                    <button id="add-piece"><span class="button-icon">+</span> <span data-i18n="add_piece_button">Thêm mảnh ván</span></button>
                </div>
            </div>

            <!-- Danh sách mảnh ván -->
            <div class="card">
                <div class="accordion-header" data-target="paint-piece-list-content">
                    <span data-i18n="piece_list">Danh sách mảnh ván (<span id="piece-count">0</span>)</span>
                    <span class="toggle-icon">▼</span>
                </div>
                <div class="accordion-content active" id="piece-list-content">
                    <div class="piece-list" id="piece-list">
                        <p data-i18n="no_pieces">Chưa có mảnh ván nào</p>
                    </div>
                    <div class="action-buttons">
                        <button id="calculate"><span class="button-icon">✓</span> <span data-i18n="calculate">Tính toán</span></button>
                        <button id="clear-pieces"><span class="button-icon">×</span> <span data-i18n="clear_all">Xóa tất cả</span></button>
                    </div>
                </div>
            </div>
        </div>

        <div class="results">
            <!-- Thống kê -->
            <div class="stats" id="stats">
                <!-- Stats will be populated here -->
            </div>

            <!-- Layout cắt ván -->
            <div class="card">
                <div class="accordion-header" data-target="layout-content">
                    <span data-i18n="layout">Layout cắt ván</span>
                    <span class="toggle-icon">▼</span>
                </div>
                <div class="accordion-content active" id="layout-content">
                    <div class="layout-tabs" id="layout-tabs">
                        <!-- Tabs will be added here -->
                    </div>
                    <div class="canvas-container" id="canvas-container">
                        <!-- Canvas elements will be added here -->
                    </div>
                    <div class="legend" id="legend">
                        <!-- Legend will be added here -->
                    </div>
                    <div class="export-buttons">
                        <button id="print-layout"><span class="button-icon">🖨️</span> <span data-i18n="print">In</span></button>
                        <button id="export-pdf"><span class="button-icon">📄</span> PDF</button>
                        <button id="zoom-fit"><span class="button-icon">🔍</span> <span data-i18n="zoom">Zoom</span></button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="jspdf.umd.min.js"></script>
    <script>
        // Language translations
        const translations = {
            vi: {
                title: "Trình Tối Ưu Cắt Ván",
                config: "Cấu hình",
                sheet_width: "Chiều rộng (m):",
                sheet_height: "Chiều dài (m):",
                cut_width: "Độ rộng cắt (mm):",
                algorithm: "Thuật toán:",
                add_piece: "Thêm mảnh ván cần cắt",
                piece_width: "Chiều rộng (m):",
                piece_height: "Chiều dài (m):",
                quantity: "Số lượng:",
                piece_name: "Tên (tùy chọn):",
                piece_name_placeholder: "VD: Mặt bàn",
                add_piece_button: "Thêm mảnh ván",
                piece_list: "Danh sách mảnh ván",
                no_pieces: "Chưa có mảnh ván nào",
                calculate: "Tính toán",
                clear_all: "Xóa tất cả",
                layout: "Layout cắt ván",
                print: "In",
                zoom: "Zoom",
                error_invalid_piece: "Kích thước mảnh ván không hợp lệ",
                error_invalid_quantity: "Số lượng không hợp lệ",
                error_piece_too_large: "Kích thước mảnh ván lớn hơn tấm ván gốc",
                error_no_pieces: "Vui lòng thêm ít nhất một mảnh ván cần cắt",
                error_invalid_sheet: "Kích thước tấm ván không hợp lệ",
                stats_sheets: "Số tấm ván",
                stats_used_area: "Diện tích sử dụng",
                stats_waste_area: "Diện tích thừa",
                stats_efficiency: "Hiệu suất",
                sheet_label: "Tấm"
            },
            en: {
                title: "Panel Cutting Optimizer",
                config: "Configuration",
                sheet_width: "Width (m):",
                sheet_height: "Length (m):",
                cut_width: "Cut width (mm):",
                algorithm: "Algorithm:",
                add_piece: "Add panel piece",
                piece_width: "Width (m):",
                piece_height: "Length (m):",
                quantity: "Quantity:",
                piece_name: "Name (optional):",
                piece_name_placeholder: "E.g., Table top",
                add_piece_button: "Add piece",
                piece_list: "Piece list",
                no_pieces: "No pieces added",
                calculate: "Calculate",
                clear_all: "Clear all",
                layout: "Cutting layout",
                print: "Print",
                zoom: "Zoom",
                error_invalid_piece: "Invalid piece dimensions",
                error_invalid_quantity: "Invalid quantity",
                error_piece_too_large: "Piece dimensions exceed panel size",
                error_no_pieces: "Please add at least one piece to cut",
                error_invalid_sheet: "Invalid panel dimensions",
                stats_sheets: "Number of panels",
                stats_used_area: "Used area",
                stats_waste_area: "Waste area",
                stats_efficiency: "Efficiency",
                sheet_label: "Panel"
            },
            ko: {
                title: "패널 절단 최적화",
                config: "설정",
                sheet_width: "너비 (m):",
                sheet_height: "길이 (m):",
                cut_width: "절단 폭 (mm):",
                algorithm: "알고리즘:",
                add_piece: "절단 조각 추가",
                piece_width: "너비 (m):",
                piece_height: "길이 (m):",
                quantity: "수량:",
                piece_name: "이름 (선택):",
                piece_name_placeholder: "예: 테이블 상판",
                add_piece_button: "조각 추가",
                piece_list: "조각 목록",
                no_pieces: "추가된 조각 없음",
                calculate: "계산",
                clear_all: "모두 지우기",
                layout: "절단 레이아웃",
                print: "인쇄",
                zoom: "확대",
                error_invalid_piece: "잘못된 조각 크기",
                error_invalid_quantity: "잘못된 수량",
                error_piece_too_large: "조각 크기가 패널 크기를 초과합니다",
                error_no_pieces: "최소한 하나의 절단 조각을 추가해주세요",
                error_invalid_sheet: "잘못된 패널 크기",
                stats_sheets: "패널 수",
                stats_used_area: "사용 면적",
                stats_waste_area: "폐기 면적",
                stats_efficiency: "효율성",
                sheet_label: "패널"
            }
        };

        // Current language
        let currentLang = 'vi';

        // Function to update text based on language
        function updateLanguage(lang) {
            currentLang = lang;
            document.documentElement.lang = lang;
            document.querySelectorAll('[data-i18n]').forEach(element => {
                const key = element.getAttribute('data-i18n');
                element.textContent = translations[lang][key] || element.textContent;
            });
            document.querySelectorAll('[data-i18n-placeholder]').forEach(element => {
                const key = element.getAttribute('data-i18n-placeholder');
                element.placeholder = translations[lang][key] || element.placeholder;
            });
            // Update piece list count
            const pieceCount = document.getElementById('piece-count').textContent;
            document.querySelector('[data-i18n="piece_list"]').innerHTML = 
                `${translations[lang].piece_list} (<span id="piece-count">${pieceCount}</span>)`;
        }

        document.addEventListener('DOMContentLoaded', function() {
            const pieceList = [];
            let packingResult = null;
            const colors = [
                '#3498db', '#e74c3c', '#2ecc71', '#f39c12', '#9b59b6',
                '#1abc9c', '#d35400', '#34495e', '#16a085', '#c0392b',
                '#27ae60', '#f1c40f', '#8e44ad', '#2980b9', '#e67e22'
            ];

            // Language switcher
            const languageButton = document.querySelector('.language-button');
            const languageMenu = document.querySelector('.language-menu');
            
            languageButton.addEventListener('click', () => {
                languageMenu.classList.toggle('active');
            });

            document.querySelectorAll('.language-menu button').forEach(button => {
                button.addEventListener('click', () => {
                    const lang = button.getAttribute('data-lang');
                    updateLanguage(lang);
                    languageMenu.classList.remove('active');
                    updatePieceList();
                    if (packingResult) {
                        displayResults(packingResult, 
                            parseFloat(sheetWidthInput.value), 
                            parseFloat(sheetHeightInput.value), 
                            parseFloat(cutWidthInput.value) / 1000
                        );
                    }
                });
            });

            // Initialize accordion functionality
            const accordionHeaders = document.querySelectorAll('.accordion-header');
            accordionHeaders.forEach(header => {
                header.addEventListener('click', function() {
                    const targetId = this.getAttribute('data-target');
                    const targetContent = document.getElementById(targetId);
                    targetContent.classList.toggle('active');
                    
                    const toggleIcon = this.querySelector('.toggle-icon');
                    toggleIcon.textContent = targetContent.classList.contains('active') ? '▼' : '►';
                });
            });

            // Elements
            const sheetWidthInput = document.getElementById('sheet-width');
            const sheetHeightInput = document.getElementById('sheet-height');
            const cutWidthInput = document.getElementById('cut-width');
            const algorithmSelect = document.getElementById('algorithm');
            const pieceWidthInput = document.getElementById('piece-width');
            const pieceHeightInput = document.getElementById('piece-height');
            const pieceQuantityInput = document.getElementById('piece-quantity');
            const pieceNameInput = document.getElementById('piece-name');
            const addPieceButton = document.getElementById('add-piece');
            const pieceListElement = document.getElementById('piece-list');
            const calculateButton = document.getElementById('calculate');
            const clearPiecesButton = document.getElementById('clear-pieces');
            const statsElement = document.getElementById('stats');
            const layoutTabsElement = document.getElementById('layout-tabs');
            const canvasContainerElement = document.getElementById('canvas-container');
            const legendElement = document.getElementById('legend');
            const printLayoutButton = document.getElementById('print-layout');
            const exportPdfButton = document.getElementById('export-pdf');
            const zoomFitButton = document.getElementById('zoom-fit');
            const pieceCountElement = document.getElementById('piece-count');
            const errorMessage = document.getElementById('error-message');

            // Add piece
            addPieceButton.addEventListener('click', function() {
                const width = parseFloat(pieceWidthInput.value);
                const height = parseFloat(pieceHeightInput.value);
                const quantity = parseInt(pieceQuantityInput.value);
                const name = pieceNameInput.value.trim() || `Mảnh ${pieceList.length + 1}`;
                
                const sheetWidth = parseFloat(sheetWidthInput.value);
                const sheetHeight = parseFloat(sheetHeightInput.value);

                                if (isNaN(width) || width <= 0 || isNaN(height) || height <= 0) {                    showError('error_invalid_piece');                    return;                }                if (isNaN(quantity) || quantity <= 0) {                    showError('error_invalid_quantity');                    return;                }                if (width > sheetWidth || height > sheetHeight) {                    if (width > sheetHeight || height > sheetWidth) {                        showError('error_piece_too_large');                        return;                    }                }

                for (let i = 0; i < quantity; i++) {
                    pieceList.push({
                        id: Date.now() + i,
                        width,
                        height,
                        name: `${name}${quantity > 1 ? ' ' + (i + 1) : ''}`
                    });
                }
                updatePieceList();
                clearPieceInputs();
            });

            // Update piece list display
            function updatePieceList() {
                pieceCountElement.textContent = pieceList.length;
                if (pieceList.length === 0) {
                    pieceListElement.innerHTML = `<p data-i18n="no_pieces">${translations[currentLang].no_pieces}</p>`;
                    return;
                }

                // Group pieces by dimensions
                const pieceGroups = {};
                pieceList.forEach(piece => {
                    const key = `${piece.width.toFixed(2)}×${piece.height.toFixed(2)}`;
                    if (!pieceGroups[key]) {
                        pieceGroups[key] = {
                            width: piece.width,
                            height: piece.height,
                            pieces: []
                        };
                    }
                    pieceGroups[key].pieces.push(piece);
                });

                pieceListElement.innerHTML = '';
                Object.keys(pieceGroups).forEach((key, index) => {
                    const group = pieceGroups[key];
                    const groupElement = document.createElement('div');
                    groupElement.className = 'piece-group';
                    groupElement.innerHTML = `
                        <div class="piece-group-header" data-group-id="${index}">
                            <span>${group.width.toFixed(2)}×${group.height.toFixed(2)}m - x${group.pieces.length} ea</span>
                            <span class="toggle-icon">▿</span>
                        </div>
                        <div class="piece-group-content" id="group-content-${index}">
                            ${group.pieces.map(piece => `
                                <div class="piece-item">
                                    <div><strong>${piece.name}</strong> - ${piece.width.toFixed(2)}×${piece.height.toFixed(2)}m</div>
                                    <button class="remove-piece" data-id="${piece.id}">${translations[currentLang].clear_all.split(' ')[0]}</button>
                                </div>
                            `).join('')}
                        </div>
                    `;
                    pieceListElement.appendChild(groupElement);
                });

                // Add toggle event listeners for group headers
                document.querySelectorAll('.piece-group-header').forEach(header => {
                    header.addEventListener('click', function() {
                        const groupId = this.getAttribute('data-group-id');
                        const content = document.getElementById(`group-content-${groupId}`);
                        content.classList.toggle('active');
                        const toggleIcon = this.querySelector('.toggle-icon');
                        toggleIcon.textContent = content.classList.contains('active') ? '▵' : '▿';
                    });
                });

                // Add remove event listeners
                document.querySelectorAll('.remove-piece').forEach(button => {
                    button.addEventListener('click', function() {
                        const id = parseInt(this.getAttribute('data-id'));
                        const index = pieceList.findIndex(piece => piece.id === id);
                        if (index !== -1) {
                            pieceList.splice(index, 1);
                            updatePieceList();
                        }
                    });
                });
            }

            // Clear piece inputs
            function clearPieceInputs() {
                pieceWidthInput.value = '0.5';
                pieceHeightInput.value = '0.5';
                pieceQuantityInput.value = '1';
                pieceNameInput.value = '';
                pieceWidthInput.focus();
            }

            // Clear all pieces
            clearPiecesButton.addEventListener('click', function() {
                pieceList.length = 0;
                updatePieceList();
                clearResults();
            });

            // Show error message
                            function showError(messageKey) {                errorMessage.textContent = translations[currentLang][messageKey] || messageKey;                errorMessage.style.display = 'block';                setTimeout(() => {                    errorMessage.style.display = 'none';                }, 3000);            }

            // Calculate button click
            calculateButton.addEventListener('click', function() {
                                if (pieceList.length === 0) {                    showError('error_no_pieces');                    return;                }                const sheetWidth = parseFloat(sheetWidthInput.value);                const sheetHeight = parseFloat(sheetHeightInput.value);                const cutWidth = parseFloat(cutWidthInput.value) / 1000;                const algorithm = algorithmSelect.value;                if (isNaN(sheetWidth) || sheetWidth <= 0 || isNaN(sheetHeight) || sheetHeight <= 0) {                    showError('error_invalid_sheet');                    return;                }

                const piecesWithCuts = pieceList.map(piece => ({
                    id: piece.id,
                    name: piece.name,
                    width: piece.width + cutWidth,
                    height: piece.height + cutWidth,
                    originalWidth: piece.width,
                    originalHeight: piece.height
                }));

                piecesWithCuts.sort((a, b) => (b.width * b.height) - (a.width * a.height));

                packingResult = algorithm === 'guillotine' 
                    ? guillotinePack(piecesWithCuts, sheetWidth, sheetHeight)
                    : maxRectsPack(piecesWithCuts, sheetWidth, sheetHeight);

                displayResults(packingResult, sheetWidth, sheetHeight, cutWidth);
            });

            // Guillotine packing algorithm
            function guillotinePack(pieces, sheetWidth, sheetHeight) {
                const sheets = [];
                let remainingPieces = [...pieces];

                while (remainingPieces.length > 0) {
                    const sheet = {
                        width: sheetWidth,
                        height: sheetHeight,
                        pieces: [],
                        freeRectangles: [{x: 0, y: 0, width: sheetWidth, height: sheetHeight}],
                        waste: sheetWidth * sheetHeight
                    };
                    sheets.push(sheet);

                    let placed = true;
                    while (placed) {
                        placed = false;
                        
                        for (let i = 0; i < remainingPieces.length; i++) {
                            const piece = remainingPieces[i];
                            
                            const placement = findBestGuillotinePlacement(piece, sheet.freeRectangles);
                            
                            if (placement) {
                                sheet.pieces.push({
                                    id: piece.id,
                                    name: piece.name,
                                    x: placement.x,
                                    y: placement.y,
                                    width: piece.originalWidth,
                                    height: piece.originalHeight,
                                    fullWidth: piece.width,
                                    fullHeight: piece.height
                                });
                                
                                splitRectangle(sheet.freeRectangles, placement);
                                remainingPieces.splice(i, 1);
                                sheet.waste -= piece.originalWidth * piece.originalHeight;
                                placed = true;
                                break;
                            }
                            
                            const rotatedPiece = {
                                id: piece.id,
                                name: piece.name,
                                width: piece.height,
                                height: piece.width,
                                originalWidth: piece.originalHeight,
                                originalHeight: piece.originalWidth
                            };
                            
                            const rotatedPlacement = findBestGuillotinePlacement(rotatedPiece, sheet.freeRectangles);
                            
                            if (rotatedPlacement) {
                                sheet.pieces.push({
                                    id: piece.id,
                                    name: piece.name,
                                    x: rotatedPlacement.x,
                                    y: rotatedPlacement.y,
                                    width: rotatedPiece.originalWidth,
                                    height: rotatedPiece.originalHeight,
                                    fullWidth: rotatedPiece.width,
                                    fullHeight: rotatedPiece.height,
                                    rotated: true
                                });
                                
                                splitRectangle(sheet.freeRectangles, rotatedPlacement);
                                remainingPieces.splice(i, 1);
                                sheet.waste -= rotatedPiece.originalWidth * piece.originalHeight;
                                placed = true;
                                break;
                            }
                        }
                    }
                }

                return calculateStats(sheets, sheetWidth, sheetHeight);
            }

            // Find best guillotine placement
            function findBestGuillotinePlacement(piece, freeRects) {
                let bestPlacement = null;
                let bestScore = Infinity;

                for (const rect of freeRects) {
                    if (rect.width >= piece.width && rect.height >= piece.height) {
                        const score = Math.min(
                            rect.width - piece.width,
                            rect.height - piece.height
                        );

                        if (score < bestScore) {
                            bestScore = score;
                            bestPlacement = {
                                x: rect.x,
                                y: rect.y,
                                width: piece.width,
                                height: piece.height,
                                rectIndex: freeRects.indexOf(rect)
                            };
                        }
                    }
                }

                return bestPlacement;
            }

            // Split rectangle after placing a piece
            function splitRectangle(freeRects, placement) {
                const rect = freeRects[placement.rectIndex];
                freeRects.splice(placement.rectIndex, 1);

                if (rect.width > placement.width) {
                    freeRects.push({
                        x: rect.x + placement.width,
                        y: rect.y,
                        width: rect.width - placement.width,
                        height: rect.height
                    });
                }

                if (rect.height > placement.height) {
                    freeRects.push({
                        x: rect.x,
                        y: rect.y + placement.height,
                        width: placement.width,
                        height: rect.height - placement.height
                    });
                }

                for (let i = freeRects.length - 1; i >= 0; i--) {
                    for (let j = i - 1; j >= 0; j--) {
                        if (isRectContained(freeRects[i], freeRects[j])) {
                            freeRects.splice(i, 1);
                            break;
                        } else if (isRectContained(freeRects[j], freeRects[i])) {
                            freeRects.splice(j, 1);
                            i--;
                            break;
                        }
                    }
                }
            }

            // MaxRects packing algorithm
            function maxRectsPack(pieces, sheetWidth, sheetHeight) {
                const sheets = [];
                let remainingPieces = [...pieces];

                while (remainingPieces.length > 0) {
                    const sheet = {
                        width: sheetWidth,
                        height: sheetHeight,
                        pieces: [],
                        freeRectangles: [{x: 0, y: 0, width: sheetWidth, height: sheetHeight}],
                        waste: sheetWidth * sheetHeight
                    };
                    sheets.push(sheet);

                    let placed = true;
                    while (placed) {
                        placed = false;
                        
                        for (let i = 0; i < remainingPieces.length; i++) {
                            const piece = remainingPieces[i];
                            
                            const placement = findBestMaxRectsPlacement(piece, sheet.freeRectangles);
                            
                            if (placement) {
                                sheet.pieces.push({
                                    id: piece.id,
                                    name: piece.name,
                                    x: placement.x,
                                    y: placement.y,
                                    width: piece.originalWidth,
                                    height: piece.originalHeight,
                                    fullWidth: piece.width,
                                    fullHeight: piece.height
                                });
                                
                                updateMaxRectsFreeRectangles(sheet.freeRectangles, placement);
                                remainingPieces.splice(i, 1);
                                sheet.waste -= piece.originalWidth * piece.originalHeight;
                                placed = true;
                                break;
                            }
                            
                            const rotatedPiece = {
                                id: piece.id,
                                name: piece.name,
                                width: piece.height,
                                height: piece.width,
                                originalWidth: piece.originalHeight,
                                originalHeight: piece.originalWidth
                            };
                            
                            const rotatedPlacement = findBestMaxRectsPlacement(rotatedPiece, sheet.freeRectangles);
                            
                            if (rotatedPlacement) {
                                sheet.pieces.push({
                                    id: piece.id,
                                    name: piece.name,
                                    x: rotatedPlacement.x,
                                    y: rotatedPlacement.y,
                                    width: rotatedPiece.originalWidth,
                                    height: rotatedPiece.originalHeight,
                                    fullWidth: rotatedPiece.width,
                                    fullHeight: rotatedPiece.height,
                                    rotated: true
                                });
                                
                                updateMaxRectsFreeRectangles(sheet.freeRectangles, rotatedPlacement);
                                remainingPieces.splice(i, 1);
                                sheet.waste -= rotatedPiece.originalWidth * rotatedPiece.originalHeight;
                                placed = true;
                                break;
                            }
                        }
                    }
                }

                return calculateStats(sheets, sheetWidth, sheetHeight);
            }

            // Find best MaxRects placement
            function findBestMaxRectsPlacement(piece, freeRects) {
                let bestPlacement = null;
                let bestScore = Infinity;

                for (const rect of freeRects) {
                    if (rect.width >= piece.width && rect.height >= piece.height) {
                        const score = Math.min(
                            rect.width - piece.width,
                            rect.height - piece.height
                        );

                        if (score < bestScore) {
                            bestScore = score;
                            bestPlacement = {
                                x: rect.x,
                                y: rect.y,
                                width: piece.width,
                                height: piece.height
                            };
                        }
                    }
                }

                return bestPlacement;
            }

            // Update MaxRects free rectangles
            function updateMaxRectsFreeRectangles(freeRects, placement) {
                const newRects = [];
                for (let i = freeRects.length - 1; i >= 0; i--) {
                    const rect = freeRects[i];
                    if (isOverlapping(rect, placement)) {
                        freeRects.splice(i, 1);
                        
                        if (rect.y < placement.y) {
                            newRects.push({
                                x: rect.x,
                                y: rect.y,
                                width: rect.width,
                                height: placement.y - rect.y
                            });
                        }
                        
                        if (rect.y + rect.height > placement.y + placement.height) {
                            newRects.push({
                                x: rect.x,
                                y: placement.y + placement.height,
                                width: rect.width,
                                height: (rect.y + rect.height) - (placement.y + placement.height)
                            });
                        }
                        
                        if (rect.x < placement.x) {
                            newRects.push({
                                x: rect.x,
                                y: rect.y,
                                width: placement.x - rect.x,
                                height: rect.height
                            });
                        }
                        
                        if (rect.x + rect.width > placement.x + placement.width) {
                            newRects.push({
                                x: placement.x + placement.width,
                                y: rect.y,
                                width: (rect.x + rect.width) - (placement.x + placement.width),
                                height: rect.height
                            });
                        }
                    }
                }
                
                freeRects.push(...newRects);
                
                for (let i = freeRects.length - 1; i >= 0; i--) {
                    for (let j = i - 1; j >= 0; j--) {
                        if (isRectContained(freeRects[i], freeRects[j])) {
                            freeRects.splice(i, 1);
                            break;
                        } else if (isRectContained(freeRects[j], freeRects[i])) {
                            freeRects.splice(j, 1);
                            i--;
                            break;
                        }
                    }
                }
            }

            // Check if rectangles overlap
            function isOverlapping(rect1, rect2) {
                return !(rect1.x >= rect2.x + rect2.width ||
                        rect1.x + rect1.width <= rect2.x ||
                        rect1.y >= rect2.y + rect2.height ||
                        rect1.y + rect1.height <= rect2.y);
            }

            // Check if rect1 is contained within rect2
            function isRectContained(rect1, rect2) {
                return rect1.x >= rect2.x && 
                       rect1.y >= rect2.y && 
                       rect1.x + rect1.width <= rect2.x + rect2.width && 
                       rect1.y + rect1.height <= rect2.y + rect2.height;
            }

            // Calculate statistics
            function calculateStats(sheets, sheetWidth, sheetHeight) {
                const totalSheets = sheets.length;
                const totalArea = totalSheets * (sheetWidth * sheetHeight);
                const totalUsedArea = sheets.reduce((sum, sheet) => 
                    sum + sheet.pieces.reduce((s, p) => s + (p.width * p.height), 0), 0);
                const efficiency = (totalUsedArea / totalArea) * 100;

                return {
                    sheets,
                    totalSheets,
                    totalArea,
                    totalUsedArea,
                    efficiency
                };
            }

            // Display results
            function displayResults(result, sheetWidth, sheetHeight, cutWidth) {
                // Display stats
                statsElement.innerHTML = `
                    <div class="stat-card">
                        <h3 style="color: black;">${translations[currentLang].stats_sheets}</h3>
                        <div class="value">${result.totalSheets}</div>
                    </div>
                    <div class="stat-card">
                        <h3 style="color: black;">${translations[currentLang].stats_used_area}</h3>
                        <div class="value">${(result.totalUsedArea).toFixed(2)} m²</div>
                    </div>
                    <div class="stat-card">
                        <h3 style="color: black;">${translations[currentLang].stats_waste_area}</h3>
                        <div class="value">${(result.totalArea - result.totalUsedArea).toFixed(2)} m²</div>
                    </div>
                        <div class="stat-card">
                        <h3 style="color: black;">${translations[currentLang].stats_efficiency}</h3>
                        <div class="value">${result.efficiency.toFixed(1)}%</div>
                    </div>
                `;

                // Create tabs and canvases
                layoutTabsElement.innerHTML = '';
                canvasContainerElement.innerHTML = '';
                result.sheets.forEach((sheet, index) => {
                    const tabButton = document.createElement('button');
                    tabButton.className = `tab-button ${index === 0 ? 'active' : ''}`;
                        tabButton.textContent = `${translations[currentLang].sheet_label} ${index + 1}`;
                        tabButton.dataset.index = index;
                    layoutTabsElement.appendChild(tabButton);

                    const canvas = document.createElement('canvas');
                    canvas.id = `canvas-${index}`;
                    canvas.style.display = index === 0 ? 'block' : 'none';
                    canvasContainerElement.appendChild(canvas);
                    drawSheet(canvas, sheet, sheetWidth, sheetHeight, index);
                });

                // Tab switching
                layoutTabsElement.querySelectorAll('.tab-button').forEach(button => {
                    button.addEventListener('click', function() {
                        layoutTabsElement.querySelector('.active').classList.remove('active');
                        this.classList.add('active');

                        canvasContainerElement.querySelectorAll('canvas').forEach(canvas => {
                            canvas.style.display = 'none';
                        });
                        document.getElementById(`canvas-${this.dataset.index}`).style.display = 'block';
                    });
                });

                // Create legend
                const legendItems = new Map();
                result.sheets.forEach(sheet => {
                    sheet.pieces.forEach((piece, index) => {
                        const key = `${piece.width.toFixed(2)}m × ${piece.height.toFixed(2)}m`;
                        if (!legendItems.has(key)) {
                            legendItems.set(key, colors[index % colors.length]);
                        }
                    });
                });

                legendElement.innerHTML = '';
                legendItems.forEach((color, dimensions) => {
                    const legendItem = document.createElement('div');
                    legendItem.className = 'legend-item';
                    legendItem.innerHTML = `
                        <div class="legend-color" style="background-color: ${color}"></div>
                        <span>${dimensions}</span>
                    `;
                    legendElement.appendChild(legendItem);
                });
            }

            // Draw sheet on canvas
            function drawSheet(canvas, sheet, sheetWidth, sheetHeight, sheetIndex) {
                const ctx = canvas.getContext('2d');
                const scale = 300 / Math.max(sheetWidth, sheetHeight);
                canvas.width = sheetWidth * scale;
                canvas.height = sheetHeight * scale;

                // Draw sheet background
                ctx.fillStyle = '#fff';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.strokeRect(0, 0, canvas.width, canvas.height);

                // Draw pieces
                sheet.pieces.forEach((piece, index) => {
                    const x = piece.x * scale;
                    const y = piece.y * scale;
                    const width = piece.width * scale;
                    const height = piece.height * scale;

                    ctx.fillStyle = colors[index % colors.length];
                    ctx.fillRect(x, y, width, height);
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(x, y, width, height);

                    // Draw piece dimensions
                    ctx.fillStyle = '#000';
                    ctx.font = '9px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    const displayWidth = piece.rotated ? piece.height : piece.width;
                    const displayHeight = piece.rotated ? piece.width : piece.height;
                    const text = `${displayWidth.toFixed(2)} × ${displayHeight.toFixed(2)}`;
                    const textWidth = ctx.measureText(text).width;

                    // Check if text fits, adjust if needed
                    if (textWidth > width * 0.9 || height < 12) {
                        ctx.font = '8px Arial';
                    }

                    if (piece.rotated) {
                        ctx.save();
                        ctx.translate(x + width / 2, y + height / 2);
                        ctx.rotate(Math.PI / 2);
                        ctx.fillText(text, 0, 0);
                        ctx.restore();
                    } else {
                        ctx.fillText(text, x + width / 2, y + height / 2);
                    }
                });

                // Draw sheet dimensions
                ctx.fillStyle = '#000';
                ctx.font = '14px Arial';
                ctx.textAlign = 'left';
                ctx.fillText(`${sheetWidth.toFixed(2)}m`, 5, canvas.height - 5);
                ctx.textAlign = 'right';
                ctx.fillText(`${sheetHeight.toFixed(2)}m`, canvas.width - 5, 15);
            }

            // Clear results
            function clearResults() {
                statsElement.innerHTML = '';
                layoutTabsElement.innerHTML = '';
                canvasContainerElement.innerHTML = '';
                legendElement.innerHTML = '';
                packingResult = null;
            }

            // Print layout
            printLayoutButton.addEventListener('click', function() {
                window.print();
            });

            // Export PDF
            exportPdfButton.addEventListener('click', async function() {
                if (!packingResult) return;

                const { jsPDF } = window.jspdf;
                const pdfDoc = new jsPDF({
                    orientation: sheetWidthInput.value > sheetHeightInput.value ? 'landscape' : 'portrait',
                    unit: 'mm',
                    format: 'a4'
                });

                packingResult.sheets.forEach((sheet, index) => {
                    if (index > 0) {
                        pdfDoc.addPage();
                    }

                    const canvas = document.getElementById(`canvas-${index}`);
                    const imgData = canvas.toDataURL('image/png');
                    const sheetWidth = parseFloat(sheetWidthInput.value);
                    const sheetHeight = parseFloat(sheetHeightInput.value);

                    // Calculate dimensions to fit A4 page (210mm x 297mm)
                    const pageWidth = pdfDoc.internal.pageSize.getWidth();
                    const pageHeight = pdfDoc.internal.pageSize.getHeight();
                    const margin = 10;
                    const maxWidth = pageWidth - 2 * margin;
                    const maxHeight = pageHeight - 2 * margin - 20; // Reserve space for title
                    const scale = Math.min(maxWidth / sheetWidth, maxHeight / sheetHeight);
                    const imgWidth = sheetWidth * scale;
                    const imgHeight = sheetHeight * scale;

                    // Add title
                    pdfDoc.setFontSize(16);
                    pdfDoc.text(`${translations[currentLang].sheet_label} ${index + 1}`, margin, margin + 10);

                    // Add canvas image
                    pdfDoc.addImage(imgData, 'PNG', margin, margin + 20, imgWidth, imgHeight);
                });

                    // Save PDF                
                    pdfDoc.save(`${translations[currentLang].title.toLowerCase().replace(/\s+/g, '_')}.pdf`);
            });

            // Zoom fit
            zoomFitButton.addEventListener('click', function() {
                if (!packingResult) return;

                canvasContainerElement.querySelectorAll('canvas').forEach(canvas => {
                    const sheetWidth = parseFloat(sheetWidthInput.value);
                    const sheetHeight = parseFloat(sheetHeightInput.value);
                    const scale = Math.min(
                        canvasContainerElement.offsetWidth / sheetWidth,
                        300 / Math.max(sheetWidth, sheetHeight)
                    );
                    canvas.style.width = `${sheetWidth * scale}px`;
                    canvas.style.height = `${sheetHeight * scale}px`;
                });
            });
        });
    </script>
</body>
</html>
