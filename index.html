<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link rel="icon" type="image/png" href="https://cdn-icons-png.flaticon.com/512/7166/7166938.png">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title data-i18n="title">Tr√¨nh T·ªëi ∆Øu C·∫Øt V√°n</title>
    <style>
        :root {
            --primary-color: #184D5A;
            --secondary-color: #2980b9;
            --accent-color: #e74c3c;
            --text-color: #333;
            --bg-color: #f9f9f9;
            --card-bg: #fff;
            --border-color: #ddd;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.5;
            color: var(--text-color);
            background-color: var(--bg-color);
            padding: 0.5rem;
        }

        h1, h2, h3 {
            margin-bottom: 0.5rem;
            color: var(--primary-color);
        }

        h1 {
            text-align: center;
            margin: 0.5rem 0 1rem;
            font-size: 1.5rem;
        }

        h2 {
            font-size: 1.2rem;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 1fr;
            gap: 0.75rem;
        }

        @media (min-width: 768px) {
            .container {
                grid-template-columns: 300px 1fr;
                gap: 1rem;
            }
            
            h1 {
                font-size: 1.8rem;
            }
        }

        .card {
            background: var(--card-bg);
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            padding: 0.75rem;
            margin-bottom: 0.75rem;
        }

        .form-group {
            margin-bottom: 0.5rem;
        }

        .form-row {
            display: flex;
            gap: 0.5rem;
        }

        .form-row .form-group {
            flex: 1;
        }

        label {
            display: block;
            margin-bottom: 0.25rem;
            font-weight: 500;
            font-size: 0.9rem;
        }

        input, button, select {
            width: 100%;
            padding: 0.5rem;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-size: 0.9rem;
        }

        button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            cursor: pointer;
            font-weight: 600;
            transition: background-color 0.3s;
            margin-top: 0.25rem;
            padding: 0.6rem;
        }

        button:hover {
            background-color: var(--secondary-color);
        }

        .piece-list {
            max-height: 200px;
            overflow-y: auto;
            margin: 0.5rem 0;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 0.25rem;
        }

        .piece-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.35rem;
            border-bottom: 1px solid var(--border-color);
            font-size: 0.9rem;
        }

        .piece-item:last-child {
            border-bottom: none;
        }

        .piece-group-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.35rem;
            cursor: pointer;
            background-color: #f5f5f5;
            border-radius: 4px;
            margin-bottom: 0.25rem;
        }

        .piece-group-header:hover {
            background-color: #eee;
        }

        .piece-group-content {
            display: none;
            padding: 0.25rem 0.5rem;
        }

        .piece-group-content.active {
            display: block;
        }

        .remove-piece {
            background: var(--accent-color);
            color: white;
            border: none;
            border-radius: 4px;
            padding: 0.2rem 0.4rem;
            cursor: pointer;
            width: auto;
            font-size: 0.8rem;
            margin-top: 0;
            margin-left: 0.5rem;
        }

        .action-buttons {
            display: flex;
            gap: 0.5rem;
        }

        .action-buttons button {
            flex: 1;
        }

        .results {
            margin-top: 0.5rem;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 0.5rem;
            margin-bottom: 0.75rem;
        }

        @media (min-width: 480px) {
            .stats {
                grid-template-columns: repeat(4, 1fr);
            }
        }

        .stat-card {
            background: var(--card-bg);
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            padding: 0.6rem;
            text-align: center;
        }

        .stat-card h3 {
            font-size: 0.8rem;
            margin-bottom: 0.25rem;
        }

        .stat-card .value {
            font-size: 1.1rem;
            font-weight: 700;
            color: var(--primary-color);
        }

        .canvas-container {
            width: 100%;
            overflow-x: auto;
            margin-top: 0.5rem;
        }

        canvas {
            border: 1px solid var(--border-color);
            background-color: white;
            margin-bottom: 1rem;
        }

        .layout-tabs {
            display: flex;
            flex-wrap: wrap;
            margin-bottom: 0.5rem;
        }

        .tab-button {
            background: #d3eafa;
            color: black;
            border: 1px solid var(--border-color);
            border-bottom: none;
            border-radius: 4px 4px 0 0;
            padding: 0.4rem 0.6rem;
            margin-right: 0.25rem;
            cursor: pointer;
            font-weight: 600;
            font-size: 0.85rem;
            transition: background-color 0.2s;
        }

        .tab-button.active {
            background: var(--primary-color);
            color: white;
        }

        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-top: 0.5rem;
            font-size: 0.85rem;
        }

        .legend-item {
            display: flex;
            align-items: center;
        }

        .legend-color {
            width: 1rem;
            height: 1rem;
            margin-right: 0.25rem;
            border: 0.0625rem solid #333;
        }

        .alert {
            background-color: #f8d7da;
            color: #721c24;
            padding: 0.5rem;
            border-radius: 4px;
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
            display: none;
        }

        .button-icon {
            margin-right: 0.25rem;
        }

        .accordion-header {
            padding: 0.5rem;
            background-color: #f0f0f0;
            cursor: pointer;
            border-radius: 4px;
            margin-bottom: 0.5rem;
            font-weight: 600;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .accordion-content {
            display: none;
            padding: 0 0.5rem;
        }

        .accordion-content.active {
            display: block;
        }

        .export-buttons {
            display: flex;
            gap: 0.3rem;
            margin-top: 0.5rem;
        }

        .export-buttons button {
            padding: 0.4rem 0.6rem;
            font-size: 0.85rem;
            min-width: 5rem;
        }

        .language-switcher {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 1000;
        }

        .language-button {
            background: var(--primary-color);
            border: none;
            border-radius: 50%;
            width: 2.5rem;
            height: 2.5rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.3s;
        }

        .language-button:hover {
            background: var(--secondary-color);
        }

        .language-menu {
            display: none;
            position: absolute;
            top: 45px;
            right: 0;
            background: white;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            min-width: 6.25rem;
        }

        .language-menu.active {
            display: block;
        }

        .language-menu button {
            display: block;
            width: 100%;
            padding: 0.5rem;
            border: none;
            background: none;
            text-align: left;
            cursor: pointer;
            font-size: 0.9rem;
        }

        .language-menu button:hover {
            background: var(--bg-color);
        }

        @media print {
            .controls, .language-switcher {
                display: none;
            }

            .container {
                display: block;
            }

            .card {
                box-shadow: none;
                border: 1px solid #ccc;
            }

            .canvas-container {
                page-break-inside: avoid;
            }

            .layout-tabs, 
            .export-buttons {
                display: none;
            }

            canvas {
                display: block !important;
            }
        }

        .layout-scroll-container {
            width: 100%;
            overflow-x: auto;
            margin-top: 0.5rem;
            -webkit-overflow-scrolling: touch;
            max-height: 80vh;
            overflow-y: auto;
            padding: 0.5rem;
            border: 0.0625rem solid var(--border-color);
            border-radius: 0.5rem;
            background: #f5f5f5;
            display: flex;
            justify-content: center;
        }

        .layouts-container {
            display: flex;
            gap: 1rem;
            padding: 0.5rem;
            min-width: min-content;
            flex-wrap: wrap;
            justify-content: center;
            max-width: 100%;
        }

        .layout-container {
            flex: 0 0 auto;
            background: white;
            border: 0.0625rem solid var(--border-color);
            border-radius: 0.5rem;
            padding: 0.5rem;
            margin-bottom: 0.5rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: 300px;
        }

        .layout-title {
            font-weight: 600;
            margin-bottom: 0.5rem;
            color: var(--primary-color);
            text-align: center;
            width: 100%;
            font-size: 1rem;
        }

        @media (max-width: 768px) {
            .layout-scroll-container {
                max-height: 60vh;
            }
            
            .layouts-container {
                flex-direction: column;
                gap: 1rem;
                align-items: center;
            }

            .layout-container {
                width: 100%;
                max-width: 31.25rem;
                min-width: unset;
            }

            canvas {
                width: 100% !important;
                height: auto !important;
            }
        }

        @media (min-width: 769px) and (max-width: 1024px) {
            .layouts-container {
                flex-wrap: wrap;
                justify-content: center;
            }

            .layout-container {
                width: calc(50% - 0.5rem);
                max-width: 25rem;
                min-width: 18.75px;
            }
        }

        @media (min-width: 1025px) {
            .layouts-container {
                flex-wrap: wrap;
                justify-content: center;
            }

            .layout-container {
                width: calc(33.33% - 0.67rem);
                max-width: 21.875rem;
                min-width: 18.75px;
            }
        }
    </style>
</head>
<body>
    <div class="language-switcher">
        <button class="language-button" title="Change Language">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-globe h-5 w-5">
                <circle cx="12" cy="12" r="10"></circle>
                <path d="M12 2a14.5 14.5 0 0 0 0 20 14.5 14.5 0 0 0 0-20"></path>
                <path d="M2 12h20"></path>
            </svg>
        </button>
        <div class="language-menu">
            <button style="color:#333;" data-lang="en">English</button>
            <button style="color:#333;" data-lang="vi">Ti·∫øng Vi·ªát</button>            
            <button style="color:#333;" data-lang="ko">ÌïúÍµ≠Ïñ¥</button>
        </div>
    </div>

    <h1 data-i18n="title">Tr√¨nh T·ªëi ∆Øu C·∫Øt V√°n</h1>
    
    <div class="container">
        <div class="controls">
            <!-- C·∫•u h√¨nh -->
            <div class="card">
                <div class="accordion-header" data-target="config-content">
                    <span data-i18n="config">C·∫•u h√¨nh</span>
                    <span class="toggle-icon">‚ñº</span>
                </div>
                <div class="accordion-content active" id="config-content">
                    <div class="form-row">
                        <div class="form-group">
                            <label for="sheet-width" data-i18n="sheet_width">Chi·ªÅu r·ªông (m):</label>
                            <input type="number" id="sheet-width" step="0.01" value="1.22">
                        </div>
                        <div class="form-group">
                            <label for="sheet-height" data-i18n="sheet_height">Chi·ªÅu d√†i (m):</label>
                            <input type="number" id="sheet-height" step="0.01" value="2.44">
                        </div>
                    </div>
                    <div class="form-row">
                        <div class="form-group">
                            <label for="cut-width" data-i18n="cut_width">ƒê·ªô r·ªông c·∫Øt (mm):</label>
                            <input type="number" id="cut-width" value="3">
                        </div>
                        <div class="form-group">
                            <label for="algorithm" data-i18n="algorithm">Thu·∫≠t to√°n:</label>
                            <select id="algorithm">
                                <option value="maxrects">MaxRects</option>
                                <option value="guillotine">Guillotine</option>
                            </select>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Th√™m m·∫£nh v√°n -->
            <div class="card">
                <div class="accordion-header" data-target="add-piece-content">
                    <span data-i18n="add_piece">Th√™m m·∫£nh v√°n c·∫ßn c·∫Øt</span>
                    <span class="toggle-icon">‚ñº</span>
                </div>
                <div class="accordion-content active" id="add-piece-content">
                    <div class="alert" id="error-message"></div>
                    <div class="form-row">
                        <div class="form-group">
                            <label for="piece-width" data-i18n="piece_width">Chi·ªÅu r·ªông (m):</label>
                            <input type="number" id="piece-width" step="0.01" value="0.5">
                        </div>
                        <div class="form-group">
                            <label for="piece-height" data-i18n="piece_height">Chi·ªÅu d√†i (m):</label>
                            <input type="number" id="piece-height" step="0.01" value="0.5">
                        </div>
                    </div>
                    <div class="form-row">
                        <div class="form-group">
                            <label for="piece-quantity" data-i18n="quantity">S·ªë l∆∞·ª£ng:</label>
                            <input type="number" id="piece-quantity" value="1" min="1">
                        </div>
                        <div class="form-group">
                            <label for="piece-name" data-i18n="piece_name">T√™n (t√πy ch·ªçn):</label>
                            <input type="text" id="piece-name" placeholder="VD: M·∫∑t b√†n" data-i18n-placeholder="piece_name_placeholder">
                        </div>
                    </div>
                    <button id="add-piece"><span class="button-icon">+</span> <span data-i18n="add_piece_button">Th√™m m·∫£nh v√°n</span></button>
                </div>
            </div>

            <!-- Danh s√°ch m·∫£nh v√°n -->
            <div class="card">
                <div class="accordion-header" data-target="paint-piece-list-content">
                    <span data-i18n="piece_list">Danh s√°ch m·∫£nh v√°n (<span id="piece-count">0</span>)</span>
                    <span class="toggle-icon">‚ñº</span>
                </div>
                <div class="accordion-content active" id="piece-list-content">
                    <div class="piece-list" id="piece-list">
                        <p data-i18n="no_pieces">Ch∆∞a c√≥ m·∫£nh v√°n n√†o</p>
                    </div>
                    <div class="action-buttons">
                        <button id="calculate"><span class="button-icon">‚úì</span> <span data-i18n="calculate">T√≠nh to√°n</span></button>
                        <button id="clear-pieces"><span class="button-icon">√ó</span> <span data-i18n="clear_all">X√≥a t·∫•t c·∫£</span></button>
                    </div>
                </div>
            </div>
        </div>

        <div class="results">
            <!-- Th·ªëng k√™ -->
            <div class="stats" id="stats">
                <!-- Stats will be populated here -->
            </div>

            <!-- Layout c·∫Øt v√°n -->
            <div class="card">
                <div class="accordion-header" data-target="layout-content">
                    <span data-i18n="layout">Layout c·∫Øt v√°n</span>
                    <span class="toggle-icon">‚ñº</span>
                </div>
                <div class="accordion-content active" id="layout-content">
                    <div class="layout-tabs" id="layout-tabs">
                        <!-- Tabs will be added here -->
                    </div>
                    <div class="canvas-container" id="canvas-container">
                        <!-- Canvas elements will be added here -->
                    </div>
                    <div class="legend" id="legend">
                        <!-- Legend will be added here -->
                    </div>
                    <div class="export-buttons">
                        <button id="print-layout"><span class="button-icon">üñ®Ô∏è</span> <span data-i18n="print">In</span></button>
                        <button id="export-pdf"><span class="button-icon">üìÑ</span> PDF</button>
                        <button id="zoom-fit"><span class="button-icon">üîç</span> <span data-i18n="zoom">Zoom</span></button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="jspdf.umd.min.js"></script>
    <script>
        // Language translations
        const translations = {
            vi: {
                title: "Tr√¨nh T·ªëi ∆Øu C·∫Øt V√°n",
                config: "C·∫•u h√¨nh",
                sheet_width: "Chi·ªÅu r·ªông (m):",
                sheet_height: "Chi·ªÅu d√†i (m):",
                cut_width: "ƒê·ªô r·ªông c·∫Øt (mm):",
                algorithm: "Thu·∫≠t to√°n:",
                add_piece: "Th√™m m·∫£nh v√°n c·∫ßn c·∫Øt",
                piece_width: "Chi·ªÅu r·ªông (m):",
                piece_height: "Chi·ªÅu d√†i (m):",
                quantity: "S·ªë l∆∞·ª£ng:",
                piece_name: "T√™n (t√πy ch·ªçn):",
                piece_name_placeholder: "VD: M·∫∑t b√†n",
                add_piece_button: "Th√™m m·∫£nh v√°n",
                piece_list: "Danh s√°ch m·∫£nh v√°n",
                no_pieces: "Ch∆∞a c√≥ m·∫£nh v√°n n√†o",
                calculate: "T√≠nh to√°n",
                clear_all: "X√≥a t·∫•t c·∫£",
                layout: "Layout c·∫Øt v√°n",
                print: "In",
                zoom: "Zoom",
                error_invalid_piece: "K√≠ch th∆∞·ªõc m·∫£nh v√°n kh√¥ng h·ª£p l·ªá",
                error_invalid_quantity: "S·ªë l∆∞·ª£ng kh√¥ng h·ª£p l·ªá",
                error_piece_too_large: "K√≠ch th∆∞·ªõc m·∫£nh v√°n l·ªõn h∆°n t·∫•m v√°n g·ªëc",
                error_no_pieces: "Vui l√≤ng th√™m √≠t nh·∫•t m·ªôt m·∫£nh v√°n c·∫ßn c·∫Øt",
                error_invalid_sheet: "K√≠ch th∆∞·ªõc t·∫•m v√°n kh√¥ng h·ª£p l·ªá",
                stats_sheets: "S·ªë t·∫•m v√°n",
                stats_used_area: "Di·ªán t√≠ch s·ª≠ d·ª•ng",
                stats_waste_area: "Di·ªán t√≠ch th·ª´a",
                stats_efficiency: "Hi·ªáu su·∫•t",
                sheet_label: "Layout"
            },
            en: {
                title: "Plywood Cutting Optimizer",
                config: "Configuration",
                sheet_width: "Width (m):",
                sheet_height: "Length (m):",
                cut_width: "Cut width (mm):",
                algorithm: "Algorithm:",
                add_piece: "Add Plywood piece",
                piece_width: "Width (m):",
                piece_height: "Length (m):",
                quantity: "Quantity:",
                piece_name: "Name (optional):",
                piece_name_placeholder: "E.g., Table top",
                add_piece_button: "Add piece",
                piece_list: "Piece list",
                no_pieces: "No pieces added",
                calculate: "Calculate",
                clear_all: "Clear all",
                layout: "Cutting layout",
                print: "Print",
                zoom: "Zoom",
                error_invalid_piece: "Invalid piece dimensions",
                error_invalid_quantity: "Invalid quantity",
                error_piece_too_large: "Piece dimensions exceed Plywood size",
                error_no_pieces: "Please add at least one piece to cut",
                error_invalid_sheet: "Invalid Plywood dimensions",
                stats_sheets: "Number of Sheet",
                stats_used_area: "Used area",
                stats_waste_area: "Waste area",
                stats_efficiency: "Efficiency",
                sheet_label: "Layout"
            },
            ko: {
                title: "Ìå®ÎÑê Ï†àÎã® ÏµúÏ†ÅÌôî",
                config: "ÏÑ§Ï†ï",
                sheet_width: "ÎÑàÎπÑ (m):",
                sheet_height: "Í∏∏Ïù¥ (m):",
                cut_width: "Ï†àÎã® Ìè≠ (mm):",
                algorithm: "ÏïåÍ≥†Î¶¨Ï¶ò:",
                add_piece: "Ï†àÎã® Ï°∞Í∞Å Ï∂îÍ∞Ä",
                piece_width: "ÎÑàÎπÑ (m):",
                piece_height: "Í∏∏Ïù¥ (m):",
                quantity: "ÏàòÎüâ:",
                piece_name: "Ïù¥Î¶Ñ (ÏÑ†ÌÉù):",
                piece_name_placeholder: "Ïòà: ÌÖåÏù¥Î∏î ÏÉÅÌåê",
                add_piece_button: "Ï°∞Í∞Å Ï∂îÍ∞Ä",
                piece_list: "Ï°∞Í∞Å Î™©Î°ù",
                no_pieces: "Ï∂îÍ∞ÄÎêú Ï°∞Í∞Å ÏóÜÏùå",
                calculate: "Í≥ÑÏÇ∞",
                clear_all: "Î™®Îëê ÏßÄÏö∞Í∏∞",
                layout: "Ï†àÎã® Î†àÏù¥ÏïÑÏõÉ",
                print: "Ïù∏ÏáÑ",
                zoom: "ÌôïÎåÄ",
                error_invalid_piece: "ÏûòÎ™ªÎêú Ï°∞Í∞Å ÌÅ¨Í∏∞",
                error_invalid_quantity: "ÏûòÎ™ªÎêú ÏàòÎüâ",
                error_piece_too_large: "Ï°∞Í∞Å ÌÅ¨Í∏∞Í∞Ä Ìå®ÎÑê ÌÅ¨Í∏∞Î•º Ï¥àÍ≥ºÌï©ÎãàÎã§",
                error_no_pieces: "ÏµúÏÜåÌïú ÌïòÎÇòÏùò Ï†àÎã® Ï°∞Í∞ÅÏùÑ Ï∂îÍ∞ÄÌï¥Ï£ºÏÑ∏Ïöî",
                error_invalid_sheet: "ÏûòÎ™ªÎêú Ìå®ÎÑê ÌÅ¨Í∏∞",
                stats_sheets: "Ìå®ÎÑê Ïàò",
                stats_used_area: "ÏÇ¨Ïö© Î©¥Ï†Å",
                stats_waste_area: "ÌèêÍ∏∞ Î©¥Ï†Å",
                stats_efficiency: "Ìö®Ïú®ÏÑ±",
                sheet_label: "Layout"
            }
        };

        // Current language
        let currentLang = localStorage.getItem('language') || 'en';

        // Function to update text based on language
        function updateLanguage(lang) {
            currentLang = lang;
            localStorage.setItem('language', lang); // Save to localStorage
            document.documentElement.lang = lang;
            document.querySelectorAll('[data-i18n]').forEach(element => {
                const key = element.getAttribute('data-i18n');
                element.textContent = translations[lang][key] || element.textContent;
            });
            document.querySelectorAll('[data-i18n-placeholder]').forEach(element => {
                const key = element.getAttribute('data-i18n-placeholder');
                element.placeholder = translations[lang][key] || element.placeholder;
            });
            // Update piece list count
            const pieceCountElement = document.getElementById('piece-count');
            if (pieceCountElement) {
                const pieceCount = pieceCountElement.textContent;
                document.querySelector('[data-i18n="piece_list"]').innerHTML = 
                    `${translations[lang].piece_list} (<span id="piece-count">${pieceCount}</span>)`;
            }
        }

        document.addEventListener('DOMContentLoaded', function() {
            // Initialize with cached or default language
            updateLanguage(currentLang);

            const pieceList = [];
            let packingResult = null;
            const colors = [
                '#3498db', '#e74c3c', '#2ecc71', '#f39c12', '#9b59b6',
                '#1abc9c', '#d35400', '#34495e', '#16a085', '#c0392b',
                '#27ae60', '#f1c40f', '#8e44ad', '#2980b9', '#e67e22'
            ];

            // Language switcher
            const languageButton = document.querySelector('.language-button');
            const languageMenu = document.querySelector('.language-menu');
            
            languageButton.addEventListener('click', () => {
                languageMenu.classList.toggle('active');
            });

            document.querySelectorAll('.language-menu button').forEach(button => {
                button.addEventListener('click', () => {
                    const lang = button.getAttribute('data-lang');
                    updateLanguage(lang);
                    languageMenu.classList.remove('active');
                    updatePieceList();
                    if (packingResult) {
                        displayResults(packingResult, 
                            parseFloat(sheetWidthInput.value), 
                            parseFloat(sheetHeightInput.value), 
                            parseFloat(cutWidthInput.value) / 1000
                        );
                    }
                });
            });

            // Initialize accordion functionality
            const accordionHeaders = document.querySelectorAll('.accordion-header');
            accordionHeaders.forEach(header => {
                header.addEventListener('click', function() {
                    const targetId = this.getAttribute('data-target');
                    const targetContent = document.getElementById(targetId);
                    targetContent.classList.toggle('active');
                    
                    const toggleIcon = this.querySelector('.toggle-icon');
                    toggleIcon.textContent = targetContent.classList.contains('active') ? '‚ñº' : '‚ñ∫';
                });
            });

            // Elements
            const sheetWidthInput = document.getElementById('sheet-width');
            const sheetHeightInput = document.getElementById('sheet-height');
            const cutWidthInput = document.getElementById('cut-width');
            const algorithmSelect = document.getElementById('algorithm');
            const pieceWidthInput = document.getElementById('piece-width');
            const pieceHeightInput = document.getElementById('piece-height');
            const pieceQuantityInput = document.getElementById('piece-quantity');
            const pieceNameInput = document.getElementById('piece-name');
            const addPieceButton = document.getElementById('add-piece');
            const pieceListElement = document.getElementById('piece-list');
            const calculateButton = document.getElementById('calculate');
            const clearPiecesButton = document.getElementById('clear-pieces');
            const statsElement = document.getElementById('stats');
            const layoutTabsElement = document.getElementById('layout-tabs');
            const canvasContainerElement = document.getElementById('canvas-container');
            const legendElement = document.getElementById('legend');
            const printLayoutButton = document.getElementById('print-layout');
            const exportPdfButton = document.getElementById('export-pdf');
            const zoomFitButton = document.getElementById('zoom-fit');
            const pieceCountElement = document.getElementById('piece-count');
            const errorMessage = document.getElementById('error-message');

            // Add piece
            addPieceButton.addEventListener('click', function() {
                const width = parseFloat(pieceWidthInput.value);
                const height = parseFloat(pieceHeightInput.value);
                const quantity = parseInt(pieceQuantityInput.value);
                const name = pieceNameInput.value.trim() || `M·∫£nh ${pieceList.length + 1}`;
                
                const sheetWidth = parseFloat(sheetWidthInput.value);
                const sheetHeight = parseFloat(sheetHeightInput.value);

                // Validate inputs
                if (isNaN(width) || width <= 0 || isNaN(height) || height <= 0) {
                    showError('error_invalid_piece');
                    return;
                }
                if (isNaN(quantity) || quantity <= 0) {
                    showError('error_invalid_quantity');
                    return;
                }
                // Check if piece can fit in either orientation
                if (!((width <= sheetWidth && height <= sheetHeight) || (width <= sheetHeight && height <= sheetWidth))) {
                    showError('error_piece_too_large');
                    return;
                }

                // Add pieces to the list
                for (let i = 0; i < quantity; i++) {
                    pieceList.push({
                        id: Date.now() + i,
                        width,
                        height,
                        name: `${name}${quantity > 1 ? ' ' + (i + 1) : ''}`
                    });
                }
                updatePieceList();
                clearPieceInputs();
            });

            // Update piece list display
            function updatePieceList() {
                if (pieceCountElement) {
                    pieceCountElement.textContent = pieceList.length;
                }
                if (pieceList.length === 0) {
                    pieceListElement.innerHTML = `<p data-i18n="no_pieces">${translations[currentLang].no_pieces}</p>`;
                    return;
                }

                // Group pieces by dimensions
                const pieceGroups = {};
                pieceList.forEach(piece => {
                    const key = `${piece.width.toFixed(2)}√ó${piece.height.toFixed(2)}`;
                    if (!pieceGroups[key]) {
                        pieceGroups[key] = {
                            width: piece.width,
                            height: piece.height,
                            pieces: []
                        };
                    }
                    pieceGroups[key].pieces.push(piece);
                });

                pieceListElement.innerHTML = '';
                Object.keys(pieceGroups).forEach((key, index) => {
                    const group = pieceGroups[key];
                    const groupElement = document.createElement('div');
                    groupElement.className = 'piece-group';
                    groupElement.innerHTML = `
                        <div class="piece-group-header" data-group-id="${index}">
                            <span>${group.width.toFixed(2)}√ó${group.height.toFixed(2)}m - x${group.pieces.length} ea</span>
                            <span class="toggle-icon">‚ñø</span>
                        </div>
                        <div class="piece-group-content" id="group-content-${index}">
                            ${group.pieces.map(piece => `
                                <div class="piece-item">
                                    <div><strong>${piece.name}</strong> - ${piece.width.toFixed(2)}√ó${piece.height.toFixed(2)}m</div>
                                    <button class="remove-piece" data-id="${piece.id}">${translations[currentLang].clear_all.split(' ')[0]}</button>
                                </div>
                            `).join('')}
                        </div>
                    `;
                    pieceListElement.appendChild(groupElement);
                });

                // Add toggle event listeners for group headers
                document.querySelectorAll('.piece-group-header').forEach(header => {
                    header.addEventListener('click', function() {
                        const groupId = this.getAttribute('data-group-id');
                        const content = document.getElementById(`group-content-${groupId}`);
                        content.classList.toggle('active');
                        const toggleIcon = this.querySelector('.toggle-icon');
                        toggleIcon.textContent = content.classList.contains('active') ? '‚ñµ' : '‚ñø';
                    });
                });

                // Add remove event listeners
                document.querySelectorAll('.remove-piece').forEach(button => {
                    button.addEventListener('click', function() {
                        const id = parseInt(this.getAttribute('data-id'));
                        const index = pieceList.findIndex(piece => piece.id === id);
                        if (index !== -1) {
                            pieceList.splice(index, 1);
                            updatePieceList();
                        }
                    });
                });
            }

            // Clear piece inputs
            function clearPieceInputs() {
                pieceWidthInput.value = '0.5';
                pieceHeightInput.value = '0.5';
                pieceQuantityInput.value = '1';
                pieceNameInput.value = '';
                pieceWidthInput.focus();
            }

            // Clear all pieces
            clearPiecesButton.addEventListener('click', function() {
                pieceList.length = 0;
                updatePieceList();
                clearResults();
            });

            // Show error message
            function showError(messageKey) {
                errorMessage.textContent = translations[currentLang][messageKey] || messageKey;
                errorMessage.style.display = 'block';
                setTimeout(() => {
                    errorMessage.style.display = 'none';
                }, 3000);
            }

            // Calculate button click
            calculateButton.addEventListener('click', function() {
                if (pieceList.length === 0) {
                    showError('error_no_pieces');
                    return; 
                }                
                const sheetWidth = parseFloat(sheetWidthInput.value);
                const sheetHeight = parseFloat(sheetHeightInput.value);
                const cutWidth = parseFloat(cutWidthInput.value) / 1000;
                const algorithm = algorithmSelect.value;
                if (isNaN(sheetWidth) || sheetWidth <= 0 || isNaN(sheetHeight) || sheetHeight <= 0) {
                    showError('error_invalid_sheet');
                    return;
                }

                const piecesWithCuts = pieceList.map(piece => ({
                    id: piece.id,
                    name: piece.name,
                    width: piece.width + cutWidth,
                    height: piece.height + cutWidth,
                    originalWidth: piece.width,
                    originalHeight: piece.height
                }));

                piecesWithCuts.sort((a, b) => (b.width * b.height) - (a.width * a.height));

                packingResult = algorithm === 'guillotine' 
                    ? guillotinePack(piecesWithCuts, sheetWidth, sheetHeight)
                    : maxRectsPack(piecesWithCuts, sheetWidth, sheetHeight);

                displayResults(packingResult, sheetWidth, sheetHeight, cutWidth);
            });

            // Guillotine packing algorithm
            function guillotinePack(pieces, sheetWidth, sheetHeight) {
                const sheets = [];
                let remainingPieces = [...pieces];

                while (remainingPieces.length > 0) {
                    const sheet = {
                        width: sheetWidth,
                        height: sheetHeight,
                        pieces: [],
                        freeRectangles: [{x: 0, y: 0, width: sheetWidth, height: sheetHeight}],
                        waste: sheetWidth * sheetHeight
                    };
                    sheets.push(sheet);

                    let placed = true;
                    while (placed) {
                        placed = false;
                        
                        for (let i = 0; i < remainingPieces.length; i++) {
                            const piece = remainingPieces[i];
                            
                            const placement = findBestGuillotinePlacement(piece, sheet.freeRectangles);
                            
                            if (placement) {
                                sheet.pieces.push({
                                    id: piece.id,
                                    name: piece.name,
                                    x: placement.x,
                                    y: placement.y,
                                    width: piece.originalWidth,
                                    height: piece.originalHeight,
                                    fullWidth: piece.width,
                                    fullHeight: piece.height
                                });
                                
                                splitRectangle(sheet.freeRectangles, placement);
                                remainingPieces.splice(i, 1);
                                sheet.waste -= piece.originalWidth * piece.originalHeight;
                                placed = true;
                                break;
                            }
                            
                            const rotatedPiece = {
                                id: piece.id,
                                name: piece.name,
                                width: piece.height,
                                height: piece.width,
                                originalWidth: piece.originalHeight,
                                originalHeight: piece.originalWidth
                            };
                            
                            const rotatedPlacement = findBestGuillotinePlacement(rotatedPiece, sheet.freeRectangles);
                            
                            if (rotatedPlacement) {
                                sheet.pieces.push({
                                    id: piece.id,
                                    name: piece.name,
                                    x: rotatedPlacement.x,
                                    y: rotatedPlacement.y,
                                    width: rotatedPiece.originalWidth,
                                    height: rotatedPiece.originalHeight,
                                    fullWidth: rotatedPiece.width,
                                    fullHeight: rotatedPiece.height,
                                    rotated: true
                                });
                                
                                splitRectangle(sheet.freeRectangles, rotatedPlacement);
                                remainingPieces.splice(i, 1);
                                sheet.waste -= rotatedPiece.originalWidth * piece.originalHeight;
                                placed = true;
                                break;
                            }
                        }
                    }
                }

                return calculateStats(sheets, sheetWidth, sheetHeight);
            }

            // Find best guillotine placement
            function findBestGuillotinePlacement(piece, freeRects) {
                let bestPlacement = null;
                let bestScore = Infinity;

                for (const rect of freeRects) {
                    if (rect.width >= piece.width && rect.height >= piece.height) {
                        const score = Math.min(
                            rect.width - piece.width,
                            rect.height - piece.height
                        );

                        if (score < bestScore) {
                            bestScore = score;
                            bestPlacement = {
                                x: rect.x,
                                y: rect.y,
                                width: piece.width,
                                height: piece.height,
                                rectIndex: freeRects.indexOf(rect)
                            };
                        }
                    }
                }

                return bestPlacement;
            }

            // Split rectangle after placing a piece
            function splitRectangle(freeRects, placement) {
                const rect = freeRects[placement.rectIndex];
                freeRects.splice(placement.rectIndex, 1);

                if (rect.width > placement.width) {
                    freeRects.push({
                        x: rect.x + placement.width,
                        y: rect.y,
                        width: rect.width - placement.width,
                        height: rect.height
                    });
                }

                if (rect.height > placement.height) {
                    freeRects.push({
                        x: rect.x,
                        y: rect.y + placement.height,
                        width: placement.width,
                        height: rect.height - placement.height
                    });
                }

                for (let i = freeRects.length - 1; i >= 0; i--) {
                    for (let j = i - 1; j >= 0; j--) {
                        if (isRectContained(freeRects[i], freeRects[j])) {
                            freeRects.splice(i, 1);
                            break;
                        } else if (isRectContained(freeRects[j], freeRects[i])) {
                            freeRects.splice(j, 1);
                            i--;
                            break;
                        }
                    }
                }
            }

            // MaxRects packing algorithm
            function maxRectsPack(pieces, sheetWidth, sheetHeight) {
                const sheets = [];
                let remainingPieces = [...pieces];

                while (remainingPieces.length > 0) {
                    const sheet = {
                        width: sheetWidth,
                        height: sheetHeight,
                        pieces: [],
                        freeRectangles: [{x: 0, y: 0, width: sheetWidth, height: sheetHeight}],
                        waste: sheetWidth * sheetHeight
                    };
                    sheets.push(sheet);

                    let placed = true;
                    while (placed) {
                        placed = false;
                        
                        for (let i = 0; i < remainingPieces.length; i++) {
                            const piece = remainingPieces[i];
                            
                            // Try original orientation
                            const placement = findBestMaxRectsPlacement(piece, sheet.freeRectangles);
                            if (placement) {
                                sheet.pieces.push({
                                    id: piece.id,
                                    name: piece.name,
                                    x: placement.x,
                                    y: placement.y,
                                    width: piece.originalWidth,
                                    height: piece.originalHeight,
                                    fullWidth: piece.width,
                                    fullHeight: piece.height,
                                    cutWidth: piece.width - piece.originalWidth
                                });
                                
                                updateMaxRectsFreeRectangles(sheet.freeRectangles, placement);
                                remainingPieces.splice(i, 1);
                                sheet.waste -= piece.originalWidth * piece.originalHeight;
                                placed = true;
                                break;
                            }
                            
                            // Try rotated orientation
                            const rotatedPiece = {
                                id: piece.id,
                                name: piece.name,
                                width: piece.height,
                                height: piece.width,
                                originalWidth: piece.originalHeight,
                                originalHeight: piece.originalWidth
                            };
                            
                            const rotatedPlacement = findBestMaxRectsPlacement(rotatedPiece, sheet.freeRectangles);
                            if (rotatedPlacement) {
                                sheet.pieces.push({
                                    id: piece.id,
                                    name: piece.name,
                                    x: rotatedPlacement.x,
                                    y: rotatedPlacement.y,
                                    width: rotatedPiece.originalWidth,
                                    height: rotatedPiece.originalHeight,
                                    fullWidth: rotatedPiece.width,
                                    fullHeight: rotatedPiece.height,
                                    rotated: true,
                                    cutWidth: rotatedPiece.width - rotatedPiece.originalWidth
                                });
                                
                                updateMaxRectsFreeRectangles(sheet.freeRectangles, rotatedPlacement);
                                remainingPieces.splice(i, 1);
                                sheet.waste -= rotatedPiece.originalWidth * rotatedPiece.originalHeight;
                                placed = true;
                                break;
                            }
                        }
                    }
                }

                return calculateStats(sheets, sheetWidth, sheetHeight);
            }

            // Find best MaxRects placement
            function findBestMaxRectsPlacement(piece, freeRects) {
                let bestPlacement = null;
                let bestScore = -Infinity;

                for (const rect of freeRects) {
                    // Check if piece fits with cut width
                    if (rect.width >= piece.width && rect.height >= piece.height) {
                        // Score based on area utilization and position
                        const score = (rect.width * rect.height) - (piece.width * piece.height);
                        
                        if (score > bestScore) {
                            bestScore = score;
                            bestPlacement = {
                                x: rect.x,
                                y: rect.y,
                                width: piece.width,
                                height: piece.height
                            };
                        }
                    }
                }

                return bestPlacement;
            }

            // Clean up free rectangles
            function cleanUpFreeRectangles(...rects) {
                const result = [];
                for (const rect of rects) {
                    let isContained = false;
                    for (const existingRect of result) {
                        if (isRectContained(rect, existingRect)) {
                            isContained = true;
                            break;
                        }
                    }
                    if (!isContained) {
                        result.push(rect);
                    }
                }
                return result;
            }

            // Update MaxRects free rectangles
            function updateMaxRectsFreeRectangles(freeRects, placement) {
                const newRects = [];
                
                for (let i = freeRects.length - 1; i >= 0; i--) {
                    const rect = freeRects[i];
                    
                    if (!isOverlapping(rect, placement)) {
                        continue;
                    }
                    
                    freeRects.splice(i, 1);
                    
                    // Generate new rectangles from the remaining space
                    // Consider cut width when creating new rectangles
                    if (rect.x < placement.x) {
                        newRects.push({
                            x: rect.x,
                            y: rect.y,
                            width: placement.x - rect.x,
                            height: rect.height
                        });
                    }
                    
                    if (rect.x + rect.width > placement.x + placement.width) {
                        newRects.push({
                            x: placement.x + placement.width,
                            y: rect.y,
                            width: (rect.x + rect.width) - (placement.x + placement.width),
                            height: rect.height
                        });
                    }
                    
                    if (rect.y < placement.y) {
                        newRects.push({
                            x: rect.x,
                            y: rect.y,
                            width: rect.width,
                            height: placement.y - rect.y
                        });
                    }
                    
                    if (rect.y + rect.height > placement.y + placement.height) {
                        newRects.push({
                            x: rect.x,
                            y: placement.y + placement.height,
                            width: rect.width,
                            height: (rect.y + rect.height) - (placement.y + placement.height)
                        });
                    }
                }
                
                // Add new rectangles after cleanup
                const cleanedRects = cleanUpFreeRectangles(...newRects);
                freeRects.push(...cleanedRects);
                
                // Remove any rectangles that are too small (including cut width)
                for (let i = freeRects.length - 1; i >= 0; i--) {
                    if (freeRects[i].width < 0.01 || freeRects[i].height < 0.01) {
                        freeRects.splice(i, 1);
                    }
                }
            }

            // Check if rectangles overlap
            function isOverlapping(rect1, rect2) {
                return !(rect1.x >= rect2.x + rect2.width ||
                        rect1.x + rect1.width <= rect2.x ||
                        rect1.y >= rect2.y + rect2.height ||
                        rect1.y + rect1.height <= rect2.y);
            }

            // Check if rect1 is contained within rect2
            function isRectContained(rect1, rect2) {
                return rect1.x >= rect2.x && 
                    rect1.y >= rect2.y && 
                    rect1.x + rect1.width <= rect2.x + rect2.width && 
                    rect1.y + rect1.height <= rect2.y + rect2.height;
            }

            // Calculate statistics
            function calculateStats(sheets, sheetWidth, sheetHeight) {
                const totalSheets = sheets.length;
                const totalArea = totalSheets * (sheetWidth * sheetHeight);
                const totalUsedArea = sheets.reduce((sum, sheet) => 
                    sum + sheet.pieces.reduce((s, p) => s + (p.width * p.height), 0), 0);
                const efficiency = (totalUsedArea / totalArea) * 100;

                return {
                    sheets,
                    totalSheets,
                    totalArea,
                    totalUsedArea,
                    efficiency
                };
            }

            // Display results
            function displayResults(result, sheetWidth, sheetHeight, cutWidth) {
                // Display stats
                statsElement.innerHTML = `
                    <div class="stat-card">
                        <h3 style="color: black;">${translations[currentLang].stats_sheets}</h3>
                        <div class="value">${result.totalSheets}</div>
                    </div>
                    <div class="stat-card">
                        <h3 style="color: black;">${translations[currentLang].stats_used_area}</h3>
                        <div class="value">${(result.totalUsedArea).toFixed(2)} m¬≤</div>
                    </div>
                    <div class="stat-card">
                        <h3 style="color: black;">${translations[currentLang].stats_waste_area}</h3>
                        <div class="value">${(result.totalArea - result.totalUsedArea).toFixed(2)} m¬≤</div>
                    </div>
                    <div class="stat-card">
                        <h3 style="color: black;">${translations[currentLang].stats_efficiency}</h3>
                        <div class="value">${result.efficiency.toFixed(1)}%</div>
                    </div>
                `;

                // Create layout container
                layoutTabsElement.innerHTML = '';
                canvasContainerElement.innerHTML = '';
                
                // Create horizontal scroll container
                const scrollContainer = document.createElement('div');
                scrollContainer.className = 'layout-scroll-container';
                canvasContainerElement.appendChild(scrollContainer);

                // Create layouts container
                const layoutsContainer = document.createElement('div');
                layoutsContainer.className = 'layouts-container';
                scrollContainer.appendChild(layoutsContainer);

                // Add all layouts
                result.sheets.forEach((sheet, index) => {
                    const layoutContainer = document.createElement('div');
                    layoutContainer.className = 'layout-container';
                    
                    const title = document.createElement('div');
                    title.className = 'layout-title';
                    title.textContent = `${translations[currentLang].sheet_label} ${index + 1}`;
                    layoutContainer.appendChild(title);

                    const canvas = document.createElement('canvas');
                    canvas.id = `canvas-${index}`;
                    layoutContainer.appendChild(canvas);
                    
                    layoutsContainer.appendChild(layoutContainer);
                    drawSheet(canvas, sheet, sheetWidth, sheetHeight, index);
                });

                // Create legend
                const legendItems = new Map();
                result.sheets.forEach(sheet => {
                    sheet.pieces.forEach((piece, index) => {
                        const key = `${piece.width.toFixed(2)}m √ó ${piece.height.toFixed(2)}m`;
                        if (!legendItems.has(key)) {
                            legendItems.set(key, colors[index % colors.length]);
                        }
                    });
                });

                legendElement.innerHTML = '';
                legendItems.forEach((color, dimensions) => {
                    const legendItem = document.createElement('div');
                    legendItem.className = 'legend-item';
                    legendItem.innerHTML = `
                        <div class="legend-color" style="background-color: ${color}"></div>
                        <span>${dimensions}</span>
                    `;
                    legendElement.appendChild(legendItem);
                });
            }

            // Draw sheet on canvas
            function drawSheet(canvas, sheet, sheetWidth, sheetHeight, sheetIndex) {
                const ctx = canvas.getContext('2d');
                const containerWidth = canvas.parentElement.offsetWidth - 20; // Tr·ª´ padding
                const displayScale = Math.min(
                    containerWidth / sheetWidth,
                    300 / Math.max(sheetWidth, sheetHeight)
                );
                const qualityScale = 5;

                // Set canvas size with higher resolution
                canvas.width = sheetWidth * displayScale * qualityScale;
                canvas.height = sheetHeight * displayScale * qualityScale;
                
                // Scale context to match display size
                ctx.scale(qualityScale, qualityScale);

                // Draw sheet background
                ctx.fillStyle = '#fff';
                ctx.fillRect(0, 0, canvas.width / qualityScale, canvas.height / qualityScale);
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2 / qualityScale;
                ctx.strokeRect(0, 0, canvas.width / qualityScale, canvas.height / qualityScale);

                // Draw pieces
                sheet.pieces.forEach((piece, index) => {
                    const x = piece.x * displayScale;
                    const y = piece.y * displayScale;
                    const width = piece.width * displayScale;
                    const height = piece.height * displayScale;

                    ctx.fillStyle = colors[index % colors.length];
                    ctx.fillRect(x, y, width, height);
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 1 / qualityScale;
                    ctx.strokeRect(x, y, width, height);

                    // Draw piece dimensions with auto-scaling text
                    const displayWidth = piece.rotated ? piece.height : piece.width;
                    const displayHeight = piece.rotated ? piece.width : piece.height;
                    const text = `${displayWidth.toFixed(2)} √ó ${displayHeight.toFixed(2)}`;
                    
                    // Calculate maximum font size that fits
                    let fontSize = Math.min(width, height) / 5;
                    ctx.font = `${fontSize}px Arial`;
                    let textWidth = ctx.measureText(text).width;
                    
                    while (textWidth > width * 0.9 && fontSize > 8) {
                        fontSize -= 1;
                        ctx.font = `${fontSize}px Arial`;
                        textWidth = ctx.measureText(text).width;
                    }

                    // Draw text
                    ctx.fillStyle = '#000';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';

                    if (piece.rotated) {
                        ctx.save();
                        ctx.translate(x + width / 2, y + height / 2);
                        ctx.rotate(Math.PI / 2);
                        ctx.fillText(text, 0, 0);
                        ctx.restore();
                    } else {
                        ctx.fillText(text, x + width / 2, y + height / 2);
                    }
                });

                // Draw sheet dimensions
                ctx.fillStyle = '#000';
                ctx.font = `${14 / qualityScale}px Arial`;
                ctx.textAlign = 'left';
                ctx.fillText(`${sheetWidth.toFixed(2)}m`, 5 / qualityScale, canvas.height / qualityScale - 5 / qualityScale);
                ctx.textAlign = 'right';
                ctx.fillText(`${sheetHeight.toFixed(2)}m`, canvas.width / qualityScale - 5 / qualityScale, 15 / qualityScale);

                // Set canvas display size
                canvas.style.width = `${sheetWidth * displayScale}px`;
                canvas.style.height = `${sheetHeight * displayScale}px`;
            }

            // Clear results
            function clearResults() {
                statsElement.innerHTML = '';
                layoutTabsElement.innerHTML = '';
                canvasContainerElement.innerHTML = '';
                legendElement.innerHTML = '';
                packingResult = null;
            }

            // Print layout
            printLayoutButton.addEventListener('click', function() {
                window.print();
            });

            // Export PDF
            exportPdfButton.addEventListener('click', async function() {
                if (!packingResult) return;

                const { jsPDF } = window.jspdf;
                const pdfDoc = new jsPDF({
                    orientation: 'landscape',
                    unit: 'mm',
                    format: 'a4'
                });

                const pageWidth = pdfDoc.internal.pageSize.getWidth();
                const pageHeight = pdfDoc.internal.pageSize.getHeight();
                const margin = 10;
                const maxWidth = (pageWidth - 4 * margin) / 3; // Divide by 3 for 3 layouts
                const maxHeight = pageHeight - 2 * margin - 20; // Reserve space for title
                const qualityScale = 2; // Increase quality scale to 10x

                // Process sheets in groups of 3
                for (let i = 0; i < packingResult.sheets.length; i += 3) {
                    if (i > 0) {
                        pdfDoc.addPage();
                    }

                    // First layout
                    const canvas1 = document.getElementById(`canvas-${i}`);
                    const tempCanvas1 = document.createElement('canvas');
                    const tempCtx1 = tempCanvas1.getContext('2d', { alpha: false });
                    tempCanvas1.width = canvas1.width * qualityScale;
                    tempCanvas1.height = canvas1.height * qualityScale;
                    tempCtx1.scale(qualityScale, qualityScale);
                    tempCtx1.imageSmoothingEnabled = true;
                    tempCtx1.imageSmoothingQuality = 'high';
                    tempCtx1.drawImage(canvas1, 0, 0);
                    
                    const imgData1 = tempCanvas1.toDataURL('image/png', 1.0);
                    const sheetWidth1 = parseFloat(sheetWidthInput.value);
                    const sheetHeight1 = parseFloat(sheetHeightInput.value);
                    
                    const scale1 = Math.min(
                        maxWidth / sheetWidth1,
                        maxHeight / sheetHeight1
                    );
                    const imgWidth1 = sheetWidth1 * scale1;
                    const imgHeight1 = sheetHeight1 * scale1;

                    // Add title for first layout
                    pdfDoc.setFontSize(14);
                    pdfDoc.text(`${translations[currentLang].sheet_label} ${i + 1}`, margin, margin + 10);

                    // Add first canvas image
                    pdfDoc.addImage(imgData1, 'PNG', margin, margin + 15, imgWidth1, imgHeight1);

                    // Second layout (if exists)
                    if (i + 1 < packingResult.sheets.length) {
                        const canvas2 = document.getElementById(`canvas-${i + 1}`);
                        const tempCanvas2 = document.createElement('canvas');
                        const tempCtx2 = tempCanvas2.getContext('2d', { alpha: false });
                        tempCanvas2.width = canvas2.width * qualityScale;
                        tempCanvas2.height = canvas2.height * qualityScale;
                        tempCtx2.scale(qualityScale, qualityScale);
                        tempCtx2.imageSmoothingEnabled = true;
                        tempCtx2.imageSmoothingQuality = 'high';
                        tempCtx2.drawImage(canvas2, 0, 0);
                        
                        const imgData2 = tempCanvas2.toDataURL('image/png', 1.0);
                        const sheetWidth2 = parseFloat(sheetWidthInput.value);
                        const sheetHeight2 = parseFloat(sheetHeightInput.value);
                        
                        const scale2 = Math.min(
                            maxWidth / sheetWidth2,
                            maxHeight / sheetHeight2
                        );
                        const imgWidth2 = sheetWidth2 * scale2;
                        const imgHeight2 = sheetHeight2 * scale2;

                        // Add title for second layout
                        pdfDoc.text(`${translations[currentLang].sheet_label} ${i + 2}`, pageWidth/3 + margin, margin + 10);

                        // Add second canvas image
                        pdfDoc.addImage(imgData2, 'PNG', pageWidth/3 + margin, margin + 15, imgWidth2, imgHeight2);
                    }

                    // Third layout (if exists)
                    if (i + 2 < packingResult.sheets.length) {
                        const canvas3 = document.getElementById(`canvas-${i + 2}`);
                        const tempCanvas3 = document.createElement('canvas');
                        const tempCtx3 = tempCanvas3.getContext('2d', { alpha: false });
                        tempCanvas3.width = canvas3.width * qualityScale;
                        tempCanvas3.height = canvas3.height * qualityScale;
                        tempCtx3.scale(qualityScale, qualityScale);
                        tempCtx3.imageSmoothingEnabled = true;
                        tempCtx3.imageSmoothingQuality = 'high';
                        tempCtx3.drawImage(canvas3, 0, 0);
                        
                        const imgData3 = tempCanvas3.toDataURL('image/png', 1.0);
                        const sheetWidth3 = parseFloat(sheetWidthInput.value);
                        const sheetHeight3 = parseFloat(sheetHeightInput.value);
                        
                        const scale3 = Math.min(
                            maxWidth / sheetWidth3,
                            maxHeight / sheetHeight3
                        );
                        const imgWidth3 = sheetWidth3 * scale3;
                        const imgHeight3 = sheetHeight3 * scale3;

                        // Add title for third layout
                        pdfDoc.text(`${translations[currentLang].sheet_label} ${i + 3}`, (pageWidth * 2/3) + margin, margin + 10);

                        // Add third canvas image
                        pdfDoc.addImage(imgData3, 'PNG', (pageWidth * 2/3) + margin, margin + 15, imgWidth3, imgHeight3);
                    }
                }

                // Save PDF                
                pdfDoc.save(`${translations[currentLang].title.toLowerCase().replace(/\s+/g, '_')}.pdf`);
            });

            // Zoom fit
            zoomFitButton.addEventListener('click', function() {
                if (!packingResult) return;

                canvasContainerElement.querySelectorAll('canvas').forEach(canvas => {
                    const sheetWidth = parseFloat(sheetWidthInput.value);
                    const sheetHeight = parseFloat(sheetHeightInput.value);
                    const scale = Math.min(
                        canvasContainerElement.offsetWidth / sheetWidth,
                        300 / Math.max(sheetWidth, sheetHeight)
                    );
                    canvas.style.width = `${sheetWidth * scale}px`;
                    canvas.style.height = `${sheetHeight * scale}px`;
                });
            });
        });
    </script>
</body>
</html>
